package service

import (
	"jobView-backend/internal/database"
	"jobView-backend/internal/model"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
)

// RegressionTestSuite 回归测试套件
type RegressionTestSuite struct {\n\tsuite.Suite\n\tdb      *database.DB\n\tservice *JobApplicationService\n\tuserID  uint\n}\n\n// SetupSuite 测试套件初始化\nfunc (suite *RegressionTestSuite) SetupSuite() {\n\tdb, service, err := setupBenchmarkService()\n\trequire.NoError(suite.T(), err, \"数据库连接应该成功\")\n\t\n\tsuite.db = db\n\tsuite.service = service\n\tsuite.userID = uint(1)\n}\n\n// TearDownSuite 测试套件清理\nfunc (suite *RegressionTestSuite) TearDownSuite() {\n\tif suite.db != nil {\n\t\tsuite.db.Close()\n\t}\n}\n\n// SetupTest 每个测试前的设置\nfunc (suite *RegressionTestSuite) SetupTest() {\n\t// 每个测试前清理可能的残留数据\n\t// 在实际项目中，这里应该有更好的数据隔离机制\n}\n\n// TestRegression_BasicCRUD 基本CRUD操作回归测试\nfunc (suite *RegressionTestSuite) TestRegression_BasicCRUD() {\n\tt := suite.T()\n\t\n\t// 1. 创建测试\n\tcreateReq := &model.CreateJobApplicationRequest{\n\t\tCompanyName:   \"回归测试公司\",\n\t\tPositionTitle: \"回归测试工程师\",\n\t\tStatus:        model.StatusApplied,\n\t\tJobDescription: \"这是一个回归测试职位\",\n\t\tSalaryRange:    \"15K-25K\",\n\t\tWorkLocation:   \"北京\",\n\t\tContactInfo:    \"test@regression.com\",\n\t\tNotes:          \"回归测试备注\",\n\t}\n\t\n\tcreatedJob, err := suite.service.Create(suite.userID, createReq)\n\trequire.NoError(t, err, \"创建操作应该成功\")\n\trequire.NotNil(t, createdJob, \"创建的记录不应该为空\")\n\t\n\t// 验证创建结果\n\tassert.NotZero(t, createdJob.ID, \"ID应该被分配\")\n\tassert.Equal(t, suite.userID, createdJob.UserID, \"用户ID应该正确\")\n\tassert.Equal(t, createReq.CompanyName, createdJob.CompanyName, \"公司名应该正确\")\n\tassert.Equal(t, createReq.PositionTitle, createdJob.PositionTitle, \"职位名应该正确\")\n\tassert.Equal(t, createReq.Status, createdJob.Status, \"状态应该正确\")\n\tassert.NotZero(t, createdJob.CreatedAt, \"创建时间应该被设置\")\n\tassert.NotZero(t, createdJob.UpdatedAt, \"更新时间应该被设置\")\n\t\n\t// 2. 读取测试\n\tretrievedJob, err := suite.service.GetByID(suite.userID, createdJob.ID)\n\trequire.NoError(t, err, \"根据ID获取应该成功\")\n\trequire.NotNil(t, retrievedJob, \"获取的记录不应该为空\")\n\t\n\t// 验证读取结果\n\tassert.Equal(t, createdJob.ID, retrievedJob.ID, \"ID应该匹配\")\n\tassert.Equal(t, createdJob.CompanyName, retrievedJob.CompanyName, \"公司名应该匹配\")\n\tassert.Equal(t, createdJob.PositionTitle, retrievedJob.PositionTitle, \"职位名应该匹配\")\n\tassert.Equal(t, createdJob.Status, retrievedJob.Status, \"状态应该匹配\")\n\t\n\t// 3. 更新测试\n\tnewStatus := model.StatusFirstInterview\n\tnewNotes := \"更新后的备注\"\n\tupdateReq := &model.UpdateJobApplicationRequest{\n\t\tStatus: &newStatus,\n\t\tNotes:  &newNotes,\n\t}\n\t\n\tupdatedJob, err := suite.service.Update(suite.userID, createdJob.ID, updateReq)\n\trequire.NoError(t, err, \"更新操作应该成功\")\n\trequire.NotNil(t, updatedJob, \"更新的记录不应该为空\")\n\t\n\t// 验证更新结果\n\tassert.Equal(t, createdJob.ID, updatedJob.ID, \"ID不应该改变\")\n\tassert.Equal(t, newStatus, updatedJob.Status, \"状态应该更新\")\n\tassert.Equal(t, newNotes, updatedJob.Notes, \"备注应该更新\")\n\tassert.True(t, updatedJob.UpdatedAt.After(updatedJob.CreatedAt), \"更新时间应该晚于创建时间\")\n\t// 未更新的字段应该保持原值\n\tassert.Equal(t, createdJob.CompanyName, updatedJob.CompanyName, \"未更新的字段应该保持不变\")\n\t\n\t// 4. 删除测试\n\terr = suite.service.Delete(suite.userID, createdJob.ID)\n\trequire.NoError(t, err, \"删除操作应该成功\")\n\t\n\t// 验证删除结果\n\t_, err = suite.service.GetByID(suite.userID, createdJob.ID)\n\tassert.Error(t, err, \"删除后应该无法获取记录\")\n\tassert.Contains(t, err.Error(), \"not found\", \"错误应该表示记录未找到\")\n}\n\n// TestRegression_QueryOptimizations 查询优化功能回归测试\nfunc (suite *RegressionTestSuite) TestRegression_QueryOptimizations() {\n\tt := suite.T()\n\t\n\t// 创建足够的测试数据\n\ttestJobs := suite.createTestDataSet(100)\n\trequire.Len(t, testJobs, 100, \"应该创建100条测试数据\")\n\t\n\tt.Run(\"GetAll查询优化回归\", func(t *testing.T) {\n\t\tstart := time.Now()\n\t\tjobs, err := suite.service.GetAll(suite.userID)\n\t\tduration := time.Since(start)\n\t\t\n\t\trequire.NoError(t, err, \"GetAll应该成功\")\n\t\tassert.NotEmpty(t, jobs, \"应该返回记录\")\n\t\tassert.LessOrEqual(t, len(jobs), 500, \"应该有LIMIT限制\")\n\t\tassert.Less(t, duration.Milliseconds(), int64(100), \"查询应该在100ms内完成\")\n\t\t\n\t\t// 验证排序正确性\n\t\tfor i := 1; i < len(jobs); i++ {\n\t\t\tassert.True(t, jobs[i-1].ApplicationDate >= jobs[i].ApplicationDate, \n\t\t\t\t\"结果应该按日期降序排列\")\n\t\t}\n\t})\n\t\n\tt.Run(\"分页查询优化回归\", func(t *testing.T) {\n\t\treq := model.PaginationRequest{\n\t\t\tPage:     1,\n\t\t\tPageSize: 10,\n\t\t\tSortBy:   \"application_date\",\n\t\t\tSortDir:  \"DESC\",\n\t\t}\n\t\t\n\t\tstart := time.Now()\n\t\tresponse, err := suite.service.GetAllPaginated(suite.userID, req)\n\t\tduration := time.Since(start)\n\t\t\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, response)\n\t\tassert.Less(t, duration.Milliseconds(), int64(50), \"分页查询应该在50ms内完成\")\n\t\t\n\t\t// 验证分页数据正确性\n\t\tassert.LessOrEqual(t, len(response.Data), 10, \"页面大小应该正确\")\n\t\tassert.Equal(t, int64(100), response.Total, \"总数应该正确\")\n\t\tassert.Equal(t, 10, response.TotalPages, \"总页数应该正确\")\n\t\tassert.True(t, response.HasNext, \"第一页应该有下一页\")\n\t\tassert.False(t, response.HasPrev, \"第一页不应该有上一页\")\n\t})\n\t\n\tt.Run(\"统计查询优化回归\", func(t *testing.T) {\n\t\tstart := time.Now()\n\t\tstats, err := suite.service.GetStatusStatistics(suite.userID)\n\t\tduration := time.Since(start)\n\t\t\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, stats)\n\t\tassert.Less(t, duration.Milliseconds(), int64(30), \"统计查询应该在30ms内完成\")\n\t\t\n\t\t// 验证统计数据\n\t\ttotalApps, ok := stats[\"total_applications\"].(int)\n\t\trequire.True(t, ok)\n\t\tassert.Equal(t, 100, totalApps, \"总申请数应该正确\")\n\t\t\n\t\tbreakdown, ok := stats[\"status_breakdown\"].(map[string]int)\n\t\trequire.True(t, ok)\n\t\tassert.NotEmpty(t, breakdown, \"状态分解应该不为空\")\n\t})\n}\n\n// TestRegression_BatchOperations 批量操作回归测试\nfunc (suite *RegressionTestSuite) TestRegression_BatchOperations() {\n\tt := suite.T()\n\t\n\tt.Run(\"批量创建回归\", func(t *testing.T) {\n\t\tapplications := generateBatchApplications(20)\n\t\t\n\t\tstart := time.Now()\n\t\tresults, err := suite.service.BatchCreate(suite.userID, applications)\n\t\tduration := time.Since(start)\n\t\t\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, results, 20, \"应该创建20条记录\")\n\t\tassert.Less(t, duration.Milliseconds(), int64(200), \"批量创建应该在200ms内完成\")\n\t\t\n\t\t// 验证每条记录\n\t\tfor i, result := range results {\n\t\t\tassert.NotZero(t, result.ID, \"记录%d应该有有效ID\", i)\n\t\t\tassert.Equal(t, suite.userID, result.UserID, \"记录%d用户ID应该正确\", i)\n\t\t\tassert.Equal(t, applications[i].CompanyName, result.CompanyName, \"记录%d公司名应该正确\", i)\n\t\t}\n\t})\n\t\n\t// 为批量更新和删除创建测试数据\n\ttestJobs := suite.createTestDataSet(30)\n\t\n\tt.Run(\"批量状态更新回归\", func(t *testing.T) {\n\t\t// 准备批量更新数据\n\t\tvar updates []model.BatchStatusUpdate\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tupdates = append(updates, model.BatchStatusUpdate{\n\t\t\t\tID:     testJobs[i].ID,\n\t\t\t\tStatus: model.StatusFirstInterview,\n\t\t\t})\n\t\t}\n\t\t\n\t\tstart := time.Now()\n\t\terr := suite.service.BatchUpdateStatus(suite.userID, updates)\n\t\tduration := time.Since(start)\n\t\t\n\t\trequire.NoError(t, err)\n\t\tassert.Less(t, duration.Milliseconds(), int64(100), \"批量更新应该在100ms内完成\")\n\t\t\n\t\t// 验证更新结果\n\t\tfor _, update := range updates {\n\t\t\tjob, err := suite.service.GetByID(suite.userID, update.ID)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, update.Status, job.Status, \"ID %d 状态应该更新成功\", update.ID)\n\t\t}\n\t})\n\t\n\tt.Run(\"批量删除回归\", func(t *testing.T) {\n\t\t// 准备要删除的ID\n\t\tvar idsToDelete []int\n\t\tfor i := 20; i < 30; i++ {\n\t\t\tidsToDelete = append(idsToDelete, testJobs[i].ID)\n\t\t}\n\t\t\n\t\tstart := time.Now()\n\t\terr := suite.service.BatchDelete(suite.userID, idsToDelete)\n\t\tduration := time.Since(start)\n\t\t\n\t\trequire.NoError(t, err)\n\t\tassert.Less(t, duration.Milliseconds(), int64(50), \"批量删除应该在50ms内完成\")\n\t\t\n\t\t// 验证删除结果\n\t\tfor _, id := range idsToDelete {\n\t\t\t_, err := suite.service.GetByID(suite.userID, id)\n\t\t\tassert.Error(t, err, \"ID %d 应该已被删除\", id)\n\t\t}\n\t})\n}\n\n// TestRegression_SearchAndFilter 搜索和筛选功能回归测试\nfunc (suite *RegressionTestSuite) TestRegression_SearchAndFilter() {\n\tt := suite.T()\n\t\n\t// 创建特定的测试数据用于搜索测试\n\ttestData := []struct {\n\t\tcompany  string\n\t\tposition string\n\t\tstatus   model.ApplicationStatus\n\t}{\n\t\t{\"腾讯科技\", \"Go后端工程师\", model.StatusApplied},\n\t\t{\"阿里巴巴\", \"Java开发工程师\", model.StatusFirstInterview},\n\t\t{\"腾讯游戏\", \"C++游戏开发\", model.StatusOfferReceived},\n\t\t{\"字节跳动\", \"前端工程师\", model.StatusRejected},\n\t\t{\"美团点评\", \"Python工程师\", model.StatusApplied},\n\t}\n\t\n\tvar createdJobs []model.JobApplication\n\tfor _, data := range testData {\n\t\treq := &model.CreateJobApplicationRequest{\n\t\t\tCompanyName:   data.company,\n\t\t\tPositionTitle: data.position,\n\t\t\tStatus:        data.status,\n\t\t}\n\t\tjob, err := suite.service.Create(suite.userID, req)\n\t\trequire.NoError(t, err)\n\t\tcreatedJobs = append(createdJobs, *job)\n\t}\n\t\n\tt.Run(\"全文搜索回归\", func(t *testing.T) {\n\t\treq := model.PaginationRequest{\n\t\t\tPage:     1,\n\t\t\tPageSize: 10,\n\t\t}\n\t\t\n\t\t// 搜索"腾讯"\n\t\tstart := time.Now()\n\t\tresults, err := suite.service.SearchApplications(suite.userID, \"腾讯\", req)\n\t\tduration := time.Since(start)\n\t\t\n\t\trequire.NoError(t, err)\n\t\tassert.Less(t, duration.Milliseconds(), int64(100), \"搜索应该在100ms内完成\")\n\t\t\n\t\t// 应该找到2条包含"腾讯"的记录\n\t\tassert.Len(t, results.Data, 2, \"应该找到2条腾讯相关记录\")\n\t\tfor _, job := range results.Data {\n\t\t\tcontainsTencent := contains(job.CompanyName, \"腾讯\") || \n\t\t\t\t\t\t\t contains(job.PositionTitle, \"腾讯\")\n\t\t\tassert.True(t, containsTencent, \"搜索结果应该包含关键词\")\n\t\t}\n\t})\n\t\n\tt.Run(\"状态筛选回归\", func(t *testing.T) {\n\t\tstatus := model.StatusApplied\n\t\treq := model.PaginationRequest{\n\t\t\tPage:     1,\n\t\t\tPageSize: 10,\n\t\t\tStatus:   &status,\n\t\t}\n\t\t\n\t\tstart := time.Now()\n\t\tresults, err := suite.service.GetAllPaginated(suite.userID, req)\n\t\tduration := time.Since(start)\n\t\t\n\t\trequire.NoError(t, err)\n\t\tassert.Less(t, duration.Milliseconds(), int64(50), \"状态筛选应该在50ms内完成\")\n\t\t\n\t\t// 验证筛选结果\n\t\tfor _, job := range results.Data {\n\t\t\tassert.Equal(t, model.StatusApplied, job.Status, \"筛选结果状态应该正确\")\n\t\t}\n\t})\n\t\n\tt.Run(\"日期范围查询回归\", func(t *testing.T) {\n\t\tstartDate := time.Now().AddDate(0, 0, -7).Format(\"2006-01-02\")\n\t\tendDate := time.Now().Format(\"2006-01-02\")\n\t\t\n\t\treq := model.PaginationRequest{\n\t\t\tPage:     1,\n\t\t\tPageSize: 20,\n\t\t}\n\t\t\n\t\tstart := time.Now()\n\t\tresults, err := suite.service.GetApplicationsByDateRange(\n\t\t\tsuite.userID, startDate, endDate, req)\n\t\tduration := time.Since(start)\n\t\t\n\t\trequire.NoError(t, err)\n\t\tassert.Less(t, duration.Milliseconds(), int64(80), \"日期范围查询应该在80ms内完成\")\n\t\t\n\t\t// 验证日期范围\n\t\tfor _, job := range results.Data {\n\t\t\tassert.True(t, job.ApplicationDate >= startDate, \n\t\t\t\t\"记录日期应该在范围内：%s >= %s\", job.ApplicationDate, startDate)\n\t\t\tassert.True(t, job.ApplicationDate <= endDate, \n\t\t\t\t\"记录日期应该在范围内：%s <= %s\", job.ApplicationDate, endDate)\n\t\t}\n\t})\n}\n\n// TestRegression_ErrorHandling 错误处理回归测试\nfunc (suite *RegressionTestSuite) TestRegression_ErrorHandling() {\n\tt := suite.T()\n\t\n\tt.Run(\"无效数据验证\", func(t *testing.T) {\n\t\t// 测试无效状态\n\t\treq := &model.CreateJobApplicationRequest{\n\t\t\tCompanyName:   \"测试公司\",\n\t\t\tPositionTitle: \"测试职位\",\n\t\t\tStatus:        model.ApplicationStatus(\"无效状态\"),\n\t\t}\n\t\t\n\t\t_, err := suite.service.Create(suite.userID, req)\n\t\tassert.Error(t, err, \"应该拒绝无效状态\")\n\t\tassert.Contains(t, err.Error(), \"invalid status\", \"错误信息应该包含状态无效\")\n\t})\n\t\n\tt.Run(\"权限检查\", func(t *testing.T) {\n\t\t// 创建一条记录\n\t\tjob, err := suite.service.Create(suite.userID, &model.CreateJobApplicationRequest{\n\t\t\tCompanyName:   \"权限测试公司\",\n\t\t\tPositionTitle: \"权限测试职位\",\n\t\t})\n\t\trequire.NoError(t, err)\n\t\t\n\t\t// 尝试用其他用户ID访问\n\t\totherUserID := uint(999)\n\t\t_, err = suite.service.GetByID(otherUserID, job.ID)\n\t\tassert.Error(t, err, \"应该拒绝其他用户访问\")\n\t\tassert.Contains(t, err.Error(), \"not found\", \"错误信息应该表示未找到\")\n\t\t\n\t\t// 尝试用其他用户ID更新\n\t\tnewStatus := model.StatusFirstInterview\n\t\tupdateReq := &model.UpdateJobApplicationRequest{Status: &newStatus}\n\t\t_, err = suite.service.Update(otherUserID, job.ID, updateReq)\n\t\tassert.Error(t, err, \"应该拒绝其他用户更新\")\n\t\t\n\t\t// 尝试用其他用户ID删除\n\t\terr = suite.service.Delete(otherUserID, job.ID)\n\t\tassert.Error(t, err, \"应该拒绝其他用户删除\")\n\t})\n\t\n\tt.Run(\"批量操作限制\", func(t *testing.T) {\n\t\t// 测试批量创建大小限制\n\t\tapplications := generateBatchApplications(51) // 超过50的限制\n\t\t_, err := suite.service.BatchCreate(suite.userID, applications)\n\t\tassert.Error(t, err, \"应该拒绝过大的批量操作\")\n\t\tassert.Contains(t, err.Error(), \"batch size too large\", \n\t\t\t\"错误信息应该包含批量大小限制\")\n\t})\n\t\n\tt.Run(\"不存在记录处理\", func(t *testing.T) {\n\t\t// 尝试获取不存在的记录\n\t\t_, err := suite.service.GetByID(suite.userID, 99999)\n\t\tassert.Error(t, err, \"获取不存在的记录应该失败\")\n\t\t\n\t\t// 尝试更新不存在的记录\n\t\tnewStatus := model.StatusFirstInterview\n\t\tupdateReq := &model.UpdateJobApplicationRequest{Status: &newStatus}\n\t\t_, err = suite.service.Update(suite.userID, 99999, updateReq)\n\t\tassert.Error(t, err, \"更新不存在的记录应该失败\")\n\t\t\n\t\t// 尝试删除不存在的记录\n\t\terr = suite.service.Delete(suite.userID, 99999)\n\t\tassert.Error(t, err, \"删除不存在的记录应该失败\")\n\t})\n}\n\n// TestRegression_DataConsistency 数据一致性回归测试\nfunc (suite *RegressionTestSuite) TestRegression_DataConsistency() {\n\tt := suite.T()\n\t\n\tt.Run(\"创建数据完整性\", func(t *testing.T) {\n\t\treq := &model.CreateJobApplicationRequest{\n\t\t\tCompanyName:     \"完整性测试公司\",\n\t\t\tPositionTitle:   \"完整性测试职位\",\n\t\t\tJobDescription:  \"详细的职位描述\",\n\t\t\tSalaryRange:     \"20K-30K\",\n\t\t\tWorkLocation:    \"上海\",\n\t\t\tContactInfo:     \"hr@test.com\",\n\t\t\tNotes:          \"重要备注\",\n\t\t\tStatus:          model.StatusApplied,\n\t\t\tApplicationDate: \"2025-09-07\",\n\t\t}\n\t\t\n\t\tcreatedJob, err := suite.service.Create(suite.userID, req)\n\t\trequire.NoError(t, err)\n\t\t\n\t\t// 验证所有字段都正确保存\n\t\tassert.Equal(t, req.CompanyName, createdJob.CompanyName)\n\t\tassert.Equal(t, req.PositionTitle, createdJob.PositionTitle)\n\t\tassert.Equal(t, req.JobDescription, createdJob.JobDescription)\n\t\tassert.Equal(t, req.SalaryRange, createdJob.SalaryRange)\n\t\tassert.Equal(t, req.WorkLocation, createdJob.WorkLocation)\n\t\tassert.Equal(t, req.ContactInfo, createdJob.ContactInfo)\n\t\tassert.Equal(t, req.Notes, createdJob.Notes)\n\t\tassert.Equal(t, req.Status, createdJob.Status)\n\t\tassert.Equal(t, req.ApplicationDate, createdJob.ApplicationDate)\n\t})\n\t\n\tt.Run(\"部分更新数据完整性\", func(t *testing.T) {\n\t\t// 先创建一条记录\n\t\toriginalJob, err := suite.service.Create(suite.userID, &model.CreateJobApplicationRequest{\n\t\t\tCompanyName:   \"原始公司\",\n\t\t\tPositionTitle: \"原始职位\",\n\t\t\tStatus:        model.StatusApplied,\n\t\t\tNotes:         \"原始备注\",\n\t\t})\n\t\trequire.NoError(t, err)\n\t\t\n\t\t// 只更新部分字段\n\t\tnewStatus := model.StatusFirstInterview\n\t\tupdateReq := &model.UpdateJobApplicationRequest{\n\t\t\tStatus: &newStatus,\n\t\t}\n\t\t\n\t\tupdatedJob, err := suite.service.Update(suite.userID, originalJob.ID, updateReq)\n\t\trequire.NoError(t, err)\n\t\t\n\t\t// 验证更新的字段\n\t\tassert.Equal(t, newStatus, updatedJob.Status, \"更新的字段应该改变\")\n\t\t// 验证未更新的字段保持不变\n\t\tassert.Equal(t, originalJob.CompanyName, updatedJob.CompanyName, \"未更新的字段应该保持不变\")\n\t\tassert.Equal(t, originalJob.PositionTitle, updatedJob.PositionTitle, \"未更新的字段应该保持不变\")\n\t\tassert.Equal(t, originalJob.Notes, updatedJob.Notes, \"未更新的字段应该保持不变\")\n\t\t// 验证时间戳更新\n\t\tassert.True(t, updatedJob.UpdatedAt.After(originalJob.UpdatedAt), \"更新时间应该改变\")\n\t\tassert.Equal(t, originalJob.CreatedAt, updatedJob.CreatedAt, \"创建时间不应该改变\")\n\t})\n\t\n\tt.Run(\"批量操作数据一致性\", func(t *testing.T) {\n\t\t// 批量创建\n\t\tapplications := generateBatchApplications(5)\n\t\tresults, err := suite.service.BatchCreate(suite.userID, applications)\n\t\trequire.NoError(t, err)\n\t\t\n\t\t// 验证批量创建的数据一致性\n\t\tfor i, result := range results {\n\t\t\tassert.Equal(t, applications[i].CompanyName, result.CompanyName, \n\t\t\t\t\"批量创建记录%d的公司名应该正确\", i)\n\t\t\tassert.Equal(t, applications[i].PositionTitle, result.PositionTitle, \n\t\t\t\t\"批量创建记录%d的职位名应该正确\", i)\n\t\t\tassert.NotZero(t, result.ID, \"批量创建记录%d应该有有效ID\", i)\n\t\t\tassert.Equal(t, suite.userID, result.UserID, \"批量创建记录%d的用户ID应该正确\", i)\n\t\t}\n\t\t\n\t\t// 验证所有记录都能独立查询到\n\t\tfor i, result := range results {\n\t\t\tretrievedJob, err := suite.service.GetByID(suite.userID, result.ID)\n\t\t\trequire.NoError(t, err, \"应该能查询到批量创建的记录%d\", i)\n\t\t\tassert.Equal(t, result.CompanyName, retrievedJob.CompanyName, \n\t\t\t\t\"查询结果应该与创建结果一致\")\n\t\t}\n\t})\n}\n\n// TestRegression_PerformanceStability 性能稳定性回归测试\nfunc (suite *RegressionTestSuite) TestRegression_PerformanceStability() {\n\tt := suite.T()\n\t\n\t// 创建基准数据\n\tbaselineDataSize := 500\n\ttestJobs := suite.createTestDataSet(baselineDataSize)\n\trequire.Len(t, testJobs, baselineDataSize)\n\t\n\tt.Run(\"性能基准验证\", func(t *testing.T) {\n\t\t// 定义性能基准（基于优化后的预期性能）\n\t\tperformanceTests := []struct {\n\t\t\tname        string\n\t\t\toperation   func() error\n\t\t\tmaxDuration time.Duration\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"GetAll查询\",\n\t\t\t\toperation: func() error {\n\t\t\t\t\t_, err := suite.service.GetAll(suite.userID)\n\t\t\t\t\treturn err\n\t\t\t\t},\n\t\t\t\tmaxDuration: 100 * time.Millisecond,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"分页查询\",\n\t\t\t\toperation: func() error {\n\t\t\t\t\treq := model.PaginationRequest{Page: 1, PageSize: 20}\n\t\t\t\t\t_, err := suite.service.GetAllPaginated(suite.userID, req)\n\t\t\t\t\treturn err\n\t\t\t\t},\n\t\t\t\tmaxDuration: 50 * time.Millisecond,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"统计查询\",\n\t\t\t\toperation: func() error {\n\t\t\t\t\t_, err := suite.service.GetStatusStatistics(suite.userID)\n\t\t\t\t\treturn err\n\t\t\t\t},\n\t\t\t\tmaxDuration: 30 * time.Millisecond,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"单条更新\",\n\t\t\t\toperation: func() error {\n\t\t\t\t\tif len(testJobs) > 0 {\n\t\t\t\t\t\tnewStatus := model.StatusFirstInterview\n\t\t\t\t\t\treq := &model.UpdateJobApplicationRequest{Status: &newStatus}\n\t\t\t\t\t\t_, err := suite.service.Update(suite.userID, testJobs[0].ID, req)\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tmaxDuration: 20 * time.Millisecond,\n\t\t\t},\n\t\t}\n\t\t\n\t\t// 多次执行每个性能测试，确保稳定性\n\t\tfor _, test := range performanceTests {\n\t\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t\tvar durations []time.Duration\n\t\t\t\titerationsCount := 10\n\t\t\t\t\n\t\t\t\tfor i := 0; i < iterationsCount; i++ {\n\t\t\t\t\tstart := time.Now()\n\t\t\t\t\terr := test.operation()\n\t\t\t\t\tduration := time.Since(start)\n\t\t\t\t\t\n\t\t\t\t\trequire.NoError(t, err, \"第%d次执行应该成功\", i+1)\n\t\t\t\t\tdurations = append(durations, duration)\n\t\t\t\t\tassert.Less(t, duration, test.maxDuration, \n\t\t\t\t\t\t\"第%d次执行应该在%v内完成，实际:%v\", i+1, test.maxDuration, duration)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 计算性能统计\n\t\t\t\tvar totalDuration time.Duration\n\t\t\t\tminDuration := durations[0]\n\t\t\t\tmaxDuration := durations[0]\n\t\t\t\t\n\t\t\t\tfor _, d := range durations {\n\t\t\t\t\ttotalDuration += d\n\t\t\t\t\tif d < minDuration {\n\t\t\t\t\t\tminDuration = d\n\t\t\t\t\t}\n\t\t\t\t\tif d > maxDuration {\n\t\t\t\t\t\tmaxDuration = d\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tavgDuration := totalDuration / time.Duration(iterationsCount)\n\t\t\t\t\n\t\t\t\tt.Logf(\"%s 性能统计 (%d次执行):\", test.name, iterationsCount)\n\t\t\t\tt.Logf(\"  平均时间: %v\", avgDuration)\n\t\t\t\tt.Logf(\"  最小时间: %v\", minDuration)\n\t\t\t\tt.Logf(\"  最大时间: %v\", maxDuration)\n\t\t\t\tt.Logf(\"  基准时间: %v\", test.maxDuration)\n\t\t\t\t\n\t\t\t\t// 验证性能稳定性（最大时间不应该超过平均时间的2倍）\n\t\t\t\tassert.Less(t, maxDuration, avgDuration*2, \n\t\t\t\t\t\"最大执行时间不应该超过平均时间的2倍\")\n\t\t\t})\n\t\t}\n\t})\n}\n\n// createTestDataSet 创建测试数据集的辅助方法\nfunc (suite *RegressionTestSuite) createTestDataSet(count int) []model.JobApplication {\n\tvar jobs []model.JobApplication\n\tcompanies := []string{\"回归测试公司A\", \"回归测试公司B\", \"回归测试公司C\", \"回归测试公司D\", \"回归测试公司E\"}\n\tpositions := []string{\"回归测试工程师\", \"质量保证工程师\", \"自动化测试工程师\", \"性能测试工程师\"}\n\tstatuses := []model.ApplicationStatus{\n\t\tmodel.StatusApplied,\n\t\tmodel.StatusResumeScreening,\n\t\tmodel.StatusFirstInterview,\n\t\tmodel.StatusSecondInterview,\n\t\tmodel.StatusOfferReceived,\n\t\tmodel.StatusRejected,\n\t}\n\t\n\tfor i := 0; i < count; i++ {\n\t\treq := &model.CreateJobApplicationRequest{\n\t\t\tCompanyName:     companies[i%len(companies)],\n\t\t\tPositionTitle:   positions[i%len(positions)],\n\t\t\tStatus:          statuses[i%len(statuses)],\n\t\t\tApplicationDate: time.Now().AddDate(0, 0, -i%100).Format(\"2006-01-02\"), // 分布在100天内\n\t\t}\n\t\t\n\t\tjob, err := suite.service.Create(suite.userID, req)\n\t\trequire.NoError(suite.T(), err, \"创建测试数据应该成功\")\n\t\tjobs = append(jobs, *job)\n\t}\n\t\n\treturn jobs\n}\n\n// TestRegressionSuite 运行回归测试套件\nfunc TestRegressionSuite(t *testing.T) {\n\tsuite.Run(t, new(RegressionTestSuite))\n}